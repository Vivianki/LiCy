<<<<<<< HEAD
% ---
% Arquivo com a metodologia do Trabalho de Conclusão de Curso dos alunos
% Gabriel Takaoka Nishimura, Felippe Demarqui Ramos e Vivian Kimie Isuyama 
% da Escola Politécnica da Universidade de São Paulo
% ---
	% ---
	\chapter{Metodologia}\label{cap-metodologia}
	% ---
	
	Nesse capítulo são discorridas as escolhas da \texttt{norma 802.15.7}, \textit{hardware} e \texttt{software}.
	
	% ---
	\section{Planejamento}\label{sec-planejamento}
	% ---
	
	% ---
	\subsection{Estrutura Analítica do Projeto}\label{subsec-eap}
	% ---
	
	A Estrutura Analítica do Projeto é uma ferramenta de gerenciamento que divide as principais entregas de um projeto. Cada entrega deve ser subdividida em tarefas até que sejam obtidos pacotes de trabalho, para que se estime recursos e tempo demandados. Neste projeto, foram definidas a partir da EAP as fases de trabalho. Observa-se que existe uma fase de gerenciamento, três fases de desenvolvimento e uma fase final para o encerramento.
	
	
	\begin{figure}[h!]
		\caption{\label{fig_eap} Estrutura Analítica do Projeto Light Cyber }
		\centering
		\scalebox{.96}{\includegraphics[width=1.0\textwidth, trim={1cm 1cm 1cm 1cm}, clip]{EAP.pdf}}
	\end{figure}
	
	% ---
	\subsection{Cronograma}\label{subsec-cronograma}
	% ---
	
	O cronograma do projeto foi planejado a partir dos pacotes de trabalho definidos na Estrutura Analítica de Projeto. Os participantes então fizeram reuniões para estimar o tempo, com a aplicação dessas estimativas a um calendário, considerando ainda as datas de entrega oficiais da disciplina. Com todas as estimativas feitas, o projeto tem a primeira e segunda fase com duração até o fim de Julho, com intuito de adiantar tanto a documentação quanto a implementação, como pode-se observar no diagrama de Gantt  \autoref{fig_gantt} abaixo.
	
	\begin{figure}[h!]
		\caption{\label{fig_gantt} Diagrama de Gantt do projeto LiCy}
		\centering
		\includegraphics[width=1.0\textwidth, trim={1cm 1cm 7cm 1cm}, clip]{gantt.pdf}
	\end{figure}
	
	% ---
	\subsection{Requisitos}\label{subsec-requisitos}
	% ---
	
	Os requisitos foram divididos primeiramente em funcionais e não-funcionais. Além disso, existem outras divisões relacionadas a hardware, software, estética e módulos do sistema. Para cada requisito foi dado um peso, conforme avaliação da relevância deste requisito para este projeto, de modo que no topo da árvore haja uma soma equivalente a 1.
	
	% ---
	\subsubsection{Requisitos Funcionais}\label{subsubsec-requisitos-func}
	% ---
	\textbf{Requisitos de hardware:} é importante observar que estes dividem-se entre a lamparina, que serve de ponto de acesso, e o módulo de celular, com pesos iguais entre os dois, já que a comunicação é bilateral e ambos têm importância equivalente. Há requisitos em comum entre esses subsistemas:
	\begin{itemize}  
		\item Estar de acordo com a norma IEEE 802.15.7, que tem o peso mais alto, já que compreende o escopo principal deste trabalho, que é implementá-la;
		\item Utilização da FPGA e de um microcontrolador, para implementar as camadas física, MAC\footnote{ Media Access Control, ou camada de enlace.},  TCP, IP e de aplicação. As justificativas para o uso desses dois componentes segue nos próximos itens;
		\item Comunicação full-duplex um a um, diz respeito a garantir a bilateralidade da comunicação entre dois nós, com recepção e transmissão independentes nas duas partes;
		\item Utilizar LED e fotodiodo, para transmitir e receber, respectivamente, os dados modulados através da luz;
		\item Filtrar a luz ambiente, que é primordial para que a recepção seja bem sucedida, do contrário pode haver muita interferência da luz que não tenha o LED como fonte. Deve fazer com que o sistema se aproxime ao máximo de um cenário ideal, onde há apenas um LED e um fotodiodo num ambiente escuro.
	\end{itemize}
	
	A lamparina possui requisitos de hardware próprios, incluindo funcionar como Access Point, ou seja, fornecer acesso a uma fonte de dados, que pode ser uma rede local, um computador, a internet, entre outros. Outro requisito importante e complementar a este, é a conexão desse módulo a alguma dessas fontes através de uma interface Ethernet.
	
	Já o módulo de celular tem como requisitos de hardware exclusivos o consumo de energia através de uma bateria e a conexão ao celular através da interface USB.	
	
	\textbf{Requisitos de software:} dividem-se entre a lamparina, o módulo de celular e o aplicativo, utilizado para receber e enviar dados para este módulo. Existem requisitos que são complementares às funções de hardware, porém correspondentes às soluções de software adotadas, como a implementação da norma IEEE 802.15.7 e a comunicação full-duplex um a um. Além destes, existem os requisitos de software comuns tanto à lamparina, ou Access Point Li-Fi, como ao módulo de telefone:
	
	\begin{itemize}  
		\item Lidar com luz ambiente, ou seja, minimizar a interferência causada por ela, e mitigar o efeito de erros, corrigindo ou descartando pacotes que os contenham;
		\item Transmissão de dados pelo módulo de celular e recepção pela lamparina, representam o mesmo fluxo de dados mas de dois lados da comunicação;
		\item Transmissão de dados e multimídia pela lamparina e recepção destes pelo módulo de celular;
	\end{itemize}
	
	O módulo de celular possui um requisito de software exclusivo, que é a utilização de um protocolo conhecido para se comunicar com o celular via USB. Do outro lado, o lamparina deve se conectar à internet e lidar com os pacotes que chegarem desta rede. 
	
	Além desses requisitos, existem também aqueles referentes ao aplicativo de celular, que deve decodificar os dados recebidos via USB, deve ser desenvolvido a fim de funcionar no sistema operacional Android e deve exibir vídeos, imagens ou websites.

	\begin{figure}[h!]
		\caption{\label{fig_req1_1} Requisitos Funcionais de Hardware}
		\centering
		\includegraphics[width=0.8\textwidth]{ReqTree1_1.pdf}
	\end{figure}

	\begin{figure}[h!]
		\caption{\label{fig_req1_2} Requisitos Funcionais de Software}
		\centering
		\includegraphics[width=0.8\textwidth]{ReqTree1_2.pdf}
	\end{figure}
	
	\subsubsection{Requisitos Não-Funcionais}\label{subsubsec-requisitos-nfunc}
	\textbf{Transmissão de dados:} Deve-se principalmente manter a velocidade da banda conforme a especificação da norma IEEE 802.15.7 para cada camada PHY correspondente. É também primordial garantir a confiabilidade na comunicação, ou seja, garantir que os bits recebidos estão corretos e quando possível e necessário, corrigi-los, com as limitações que serão discutidas posteriormente no que diz respeito à norma (ver módulos de codificação e decodificação). Além disso, há um requisito de segurança, que equivale a evitar a possibilidade de vazamento de dados para terceiros, ou até a intromissão de mensagens indesejadas na comunicação.
	\textbf{Modulação de luz:} O requisito mais importante é garantir o funcionamento do sistema a uma distância de até 1 metro, considerando uma aplicação residencial do produto. Secundariamente, há o requisito de manter um baixo consumo de energia, que apesar de fundamental em produtos de tecnologia da informação, foge do escopo deste estudo.
	
	\begin{figure}[h!]
		\caption{\label{fig_req2} Requisitos Não Funcionais}
		\centering		%  trim={<left> <lower> <right> <upper>} 
		\includegraphics[width=0.9\textwidth, trim={1cm 5.5cm 1cm 6cm}, clip]{ReqTree2.pdf}
	\end{figure}
	
	\begin{figure}[h!]
		\caption{\label{fig_req3} Outros Requisitos}
		\centering
		\includegraphics[width=0.7\textwidth, trim={1cm 4cm 3cm 4cm}, clip]{ReqTree3.pdf}
	\end{figure}
	
	% ---
	\section{Norma IEEE 802.15.7}\label{sec-norma}
	% ---
	
	A norma 802.15.7 estabelece um padrão para comunicação via luz, no que se diz respeito à definição de topologias de rede, codificação da informação, divisão das camadas da arquitetura do sistema de comunicação, ordem e conteúdo de cabeçalhos para cada camada e definições sobre a segurança do \textit{link}. A arquitetura de um sistema LiFi completo está definida na \autoref{fig_architecture}.
	
	\begin{figure}[htb]
		\caption{\label{fig_architecture} Arquitetura de dispositivos VPAN}
		\centering
		\includegraphics[width=0.5\textheight,trim={5.5cm 9.6cm 5.3cm 7cm}, clip]{pag31.pdf}
		\legend{Fonte: IEEE 802.15.7}
	\end{figure}
	
	O trabalho focará no estudo e implementação das camadas PHY e MAC.
	
%	\begin{figure}[htb]
%		\caption{\label{fig_transmission_simple_blocs} Diagrama de blocos simplificado da transmissão da camada PHY I}
%		\centering
%		\includegraphics[width=0.4\textheight]{transmissao-blocos-simplificado.pdf}
%	\end{figure}

	\subsection{Transmissão}
	
	Nessa seção será discorrido o processo de transmissão de dados via luz, levando em conta códigos cíclicos de correção de erro, redução de erros em burst e protocolos RLL, especificados pela norma IEEE. Para realizar a transmissão, é necessário passar pelas etapas do diagrama abaixo:
		
		\begin{figure}[htb]
			\caption{\label{fig_transmission_phy1} Diagrama de blocos da codificação da mensagem}
			\centering
			\includegraphics[width=0.6\textheight]{PHY1-transmission.pdf}
			\legend{Fonte: @todo figura 126}
		\end{figure}
		
	Para que os dados transmitidos sejam corretamente recebidos, a norma estabelece algumas regras para codificação da mensagem, a fim de garantir recuperação de erros, redução de erros em burst, maior facilidade na sincronia do clock, entre outros detalhes. A \autoref{fig_transmission_phy1} ilustra os passos necessários para compor a mensagem antes de sua transmissão. Esses passos estarão detalhados nas seções a seguir.
	
	
	\subsubsection{Codificação Reed Solomon}
	
	Com intuito de adicionar redundância de informação na mensagem, a norma estabelece um mecanismo de correção de erros antecipada (FEC). Mais especificamente, o código de Reed Solomon. 
	
	Os códigos Reed Solomon são compostos por símbolos de mais de um bit. O número de erros é considerado como sendo o total de símbolos com pelo menos um bit com erro. Isso o torna efetivo para corrigir erros em rajadas, já que uma sequência de bits errados dentro de um mesmo símbolo é considerada como apenas um erro. 
	
	Os principais parâmetros de um código Reed Solomon são $(n, k)$, onde $n$ é o número de símbolos de um bloco de código e $k$ é o tamanho da mensagem em número de símbolos. Portanto, o bloco terá $n - k$ símbolos de paridade, usualmente designados como $2t$, sendo que a capacidade de correção é de até $t$ símbolos.
	
	Campos de Galois
	
	A codificação e decodificação de Reed Solomon usam em seus algoritmos operações aritméticas de multiplicação e adição de campos finitos. A norma 802.15.7 define que para a camada PHY 1, usa-se Galois Fields 16, ou na notação corrente na literatura: GF(16). Um campo de Galois é um conjunto de $2m - 1$ elementos, cada qual representado por um polinômio de grau $m - 1$, com coeficientes binários. Em suma, um elemento de GF(16) pode ser representado a partir de símbolos de 4 bits, totalizando 16 elementos de 0000 a 1111. 
	
	A adição e subtração de dois campos de Galois é dada pela soma ou subtração dos coeficientes de dois polinômios. Além disso as operações são feitas bit a bit, sem que haja bits de "vai um" para coeficientes subsequentes. Caso os dois coeficientes tenham o mesmo valor, que pode ser 1 ou 0, o resultado da sua soma ou subtração deve ser 0. Caso contrário, a soma equivale a 1, de maneira que essa operação é perfeitamente representável pela função lógica de OU exclusivo, para ambas adição e subtração.
	
	Os campos de Galois são definidos com base no gerador polinomial de campos, que é um polinômio irredutível, de grau $m$. Para GF(16) existe por exemplo, esta opção:
	
	\begin{equation}
	p(x) = x^{4} + x + 1 
	\end{equation}
	
	
	A norma IEEE 802.7.15 não especifica qual gerador polinomial deve ser usado, portanto neste estudo foi usada a opção do exemplo. O processo de geração neste caso resulta nos seguintes elementos finitos:
	 
	\begin{table}[]
		\centering
		\caption{Campos de Galois (16)}
		\label{my-label}
		\begin{tabular}{|c|c|}
			\hline
			Elemento & Representação binária \\ \hline
			$\alpha^{0}$   & 0001                  \\ \hline
			$\alpha^{1}$   & 0010                  \\ \hline
			$\alpha^{2}$   & 0100                  \\ \hline
			$\alpha^{3}$   & 1000                  \\ \hline
			$\alpha^{4}$   & 0011                  \\ \hline
			$\alpha^{5}$   & 0110                  \\ \hline
			$\alpha^{6}$   & 1100                  \\ \hline
			$\alpha^{7}$   & 1011                  \\ \hline
			$\alpha^{8}$   & 0101                  \\ \hline
			$\alpha^{9}$   & 1010                  \\ \hline
			$\alpha^{10}$  & 0111                  \\ \hline
			$\alpha^{11}$  & 1110                  \\ \hline
			$\alpha^{12}$  & 1111                  \\ \hline
			$\alpha^{13}$  & 1101                  \\ \hline
			$\alpha^{14}$  & 1001                  \\ \hline
			$\alpha^{15}$  & 0000                  \\ \hline
		\end{tabular}
	\end{table}
	 
	A multiplicação entre dois campos de Galois ocorre, em termos de aritmética comum, pela multiplicação de dois polinômios, seguida da divisão pelo gerador polinomial. Já a divisão  de campos finitos pode ser feita através da operação de inversão do divisor e multiplicação desse resultado pelo dividendo, seguindo os passos indicados anteriormente para a multiplicação. 
	 
	 Codificação 
	 
	Para gerar um código de Reed Solomon a partir dos campos finitos, é necessário um polinômio gerador de código. Este polinômio possui $2t$ fatores, de maneira que o grau do polinômio representado por $C(x)$ (bloco codificado, com grau $n$) seja a soma do grau de $M(x)$ (a própria mensagem dentro do bloco codificado, com grau $k$) e $G(x)$ (polinômio codificador, com grau $2t = n - k$). O polinômio gerador de código deve ter a seguinte forma:
	 
	\begin{equation}
	g(x) = (x + \alpha^{i})(x + \alpha^{i+1})...(x + \alpha^{i + 2t - 1})  
	\end{equation}
	
	
	As raízes são escolhidas como campos finitos de Galois consecutivos. Para esse estudo, usaram-se como raízes os elementos consecutivos de $\alpha^{0}$ a $\alpha^{7}$. Por exemplo, para um código (15, 7), usado posteriormente neste projeto:
	 
	\begin{equation}
	g(x) = (x + \alpha^{0})(x + \alpha^{1})(x + \alpha^{2})(x + \alpha^{3})(x + \alpha^{4})(x + \alpha^{5})(x + \alpha^{6})(x + \alpha^{7})
	\end{equation}
	 
	\begin{equation}
	g(x) = \alpha^{13}x^{7} + \alpha^{0}x^{6} + \alpha^{1}x^{5} + \alpha^{13}x^{4} + \alpha^{8}x^{3} + \alpha^{14}x^{2} + \alpha^{4}x + \alpha^{13}
	\end{equation}
	
	
	Neste caso, a mensagem $M(x)$ é codificada da seguinte maneira:
	
	
	\begin{equation}
	\frac{M(x)x^{n-k}}{G(x)} = q(x) + \frac{r(x)}{g(x)}
	\end{equation}
	
	 
	Desta forma, são produzidos um quociente $q(x)$ e um resto $r(x)$. Por manipulação algébrica, temos que o bloco codificado pode ser representado da seguinte forma:
	 
	\begin{equation}
	M(x)x^{n-k} + r(x) = g(x)q(x)
	\end{equation}
	
	
	Portanto o bloco codificado $C(x)$ é composto por $M(x)$ deslocada, somada a $r(x)$, na prática equivalendo à \autoref{fig_reed_solomon_message}, com os símbolos de dados transmitidos em esquema de fila, seguidos dos símbolos de paridade.
	
	\begin{figure}[htb]
		\caption{\label{fig_reed_solomon_message} Diagrama de blocos da codificação da mensagem}
		\centering
		\includegraphics[width=0.5\textheight]{reed_solomon_message.pdf}
	\end{figure}
	
	Finalmente, a representação do codificador de Reed Solomon (15, 7) em hardware equivale a:
	 
	\begin{figure}[htb]
		\caption{\label{RS_encoder_logic} Circuito lógico de codificação Reed Solomon (15,7)}
		\centering
		\includegraphics[width=0.7\textheight]{RS_Encoder.png}
		\legend{Fonte: @todo figura 126}
	\end{figure}
	
	É possível observar nos registradores e multiplicadores de Galois a estrutura de um polinômio e seus índices. A mensagem a que se vai adicionar redundância deve passar por "entrada", com um ciclo de clock para cada símbolo, levando portanto 7 ciclos para finalizar o cálculo das paridades para um código (15, 7). Os 8 símbolos de paridade devem então ser passados através de deslocamento de registradores, com a mudança do sinal de seleção, de maneira também a zerar a saída da porta lógica AND à direita. Sendo assim, os valores dos registradores não são afetados pelos somadores, já que as operações de multiplicação e soma de Galois estarão recebendo uma das entradas igual a 0000. Em suma, o processo de codificação leva tantos ciclos quantos forem os símbolos do bloco codificado, ou o valor denotado por $n$.
	
	 
	\cite{nasa-rs1}

		
	
	\subsubsection{Padding}
	
	Esse processo se aplica a mensagens curtas e consiste em preencher espaços vazios com zeros.
	
	\subsubsection{Interleaver}
	
	O processo de entrelaçamento é utilizado para aprimorar a performance de mecanismos de correção de erros antecipados. Ele se baseia no fato de que canais de comunicação não são estocásticos, então erros ocorrem em sequência e não independentemente. 
	
	O entrelaçamento serve para distribuir os erros em sequência, facilitando o processo de recuperação de erros, pois os erros serão distribuídos em múltiplas palavras de código. 
	
	Para melhor demonstrar a aplicação do entrelaçador, serão exemplificadas várias situações utilizado um sistema de recuperação de erros em um canal com ruídos (que costumam ser \textit{bit-flip}). Na primeira, não é aplicado o entrelaçamento e a mensagem é recuperável com redundância.

	\begin{verbatim}
	   Burst = 2, Redundância = 3, Sem entrelaçamento
	   Mensagem inicial:                             abcdefg
	   Mensagem com redundância:                     aaabbbcccdddeeefffggg
	   Transmissão com erros em burst:               aaabbbc__dddeeefffggg
	   Mensagem recuperada:                          abcdefg
	\end{verbatim}

	Mesmo após dois caracteres perdidos em sequência, foi possível recuperar as perdas do canal. Isso ocorreu pois o burst do erro foi menor que sua capacidade de recuperação. Na situação a seguir, novamente sem entrelaçamento, a mensagem não é recuperável com redundância.
	
	\begin{verbatim}
	   Burst = 4, Redundância = 3, Sem entrelaçamento
	   Mensagem inicial:                             abcdefg
	   Mensagem com redundância:                     aaabbbcccdddeeefffggg
	   Transmissão com erros em burst:               aaabbbcc____eeefffggg
	   Mensagem recuperada:                          abc_efg
	\end{verbatim}
	
	Mesmo com a redundância aplicada, a informação \textit{d} foi perdida devido à erros em burst. Aplicando entrelaçamento, a mesma mensagem pode ser recuperada facilmente, a seguir:
	
	\begin{verbatim}
	   Burst = 4, Redundância = 3, Com entrelaçamento
	   Mensagem inicial:                             abcdefg
	   Mensagem com redundância:                     aaabbbcccdddeeefffggg
	   Interleaving:                                 abcdefgabcdefgabcdefg
	   Transmissão com erros em sequência:           abcdefgab____gabcdefg
	   Deinterleaving:                               aaabbbc_cd_de_ef_fggg
	   Mensagem recuperada:                          abcdefg
	\end{verbatim}
	
	A mensagem recebida foi recuperada pois os erros foram distribuídos em partes diferentes da mensagem, que foi entrelaçada. Os dados resultantes puderam ser inferidos pela redundância aplicada. A norma especifica alguns parâmetros que devem ser definidos para criar o entrelaçador:
	
	\begin{verbatim}
	n: RS codeword length
	k: Number of information data symbols in a RS codeword
	q: Number of elements in the Galois field: GF(q)
	L_{frame}: Input frame size in bytes
	S_{frame}: Number of symbols at the input of the RS encoder
	S: Number of symbols from the output of the shortened RS encoder
	S_{block}: The size of the interleaver used
	D:The interleaving depth
	i: Ordered indices take the values 0, 1, …, Sblock–1
	l(i): Interleaved indices
	p: Number of zero RS symbols
	t: Ordered indices take the values 0, 1, …, p
	z(t): Locations of the bits to be punctured at the output of the 
	interleaver before transmission 
	\end{verbatim}
	
	\subsubsection{Puncture}
	
	O módulo de punção é utilizado para reduzir o overhead do padding, e é aplicado depois do interleaver.
	
	\subsubsection{Convolutional Encoder}
	
	Este módulo 
	
	\subsubsection{Codificação RLL}
	
	Para a primeira camada de implementação PHY I, será escolhida codificação RLL Manchester. A codificação Manchester divide o bit do dado ao meio, de maneira que a primeira metade deve obrigatoriamente assumir um valor diferente da segunda metade. Em outras palavras, caso a entrada a ser codificada seja 0 por um tempo $2t$, a saída deve ser 01, com cada bit com tempo $t$ de transmissão como se verifica em \autoref{tabela_cod_manchester}. Analogamente, caso o bit de entrada seja 1, a saída deve ser 10.
	
	\begin{table}[ht]
		\caption{Codificação Manchester}
		\centering
		\begin{tabular}{c c}
			\hline
			bit & manchester symbol \\ \hline
			0 & 01 \\
			1 & 10 \\ \hline
		\end{tabular}
		\label{tabela_cod_manchester}
		\legend{Fonte: Tabela 103 da norma 802.15.7}
	\end{table}
	
	Uma maneira prática de se obter um codificador Manchester é através da aplicação da operação de OU exlcusivo, ou XOR em dois sinais de entrada. Um destes sinais é a própria mensagem a ser codificada, o outro sinal deve ser um clock com o dobro da frequência da mensagem. É importante observar que para essa codificação ser eficiente, os dois sinais devem estar sincronizados, de maneira que um período de clock seja exatamente equivalente à duração do bit da mensagem de entrada.
	
	
	
	\subsection{Recepção}
	
	Após a codificação dos dados, é necessário realizar a decodificação deles. Para isso, deve-se reverter os processos aplicados pela seção anterior. No entanto, isso não é tão trivial, dado que vários desses módulos devem realizar correção de erro, tornando o algoritmo completamente diferente. As etapas de decodificação dos dados estão esquematizadas abaixo:

	\begin{figure}[htb]
		\caption{\label{fig_transmission_phy1} Diagrama de blocos da codificação da mensagem}
		\centering
		\includegraphics[width=0.6\textheight]{PHY1-transmission.pdf}
		\legend{Fonte: @todo figura 126}
	\end{figure}

	Esses passos estarão detalhados abaixo:
	
	
	\subsubsection{Decodificação RLL}
	
	A decodificação do código Manchester ocorre da mesma forma que a codificação, porém com um sinal de clock cuja frequência é idêntica à do clock de codificação. Portanto, o período do clock deve ser o dobro do tempo de duração do bit da mensagem. Uma consequência dessa definição é que os dados transmitidos entre um codificador e um decodificador Manchester têm o dobro da frequência da mensagem original, embora a frequência com que dados efetivos são transmitidos seja a mesma.
	
	A identificação de erros pode acontecer de mais de uma forma. É possível, por exemplo, criar uma máquina de estados que identifique a entrada de dois bits idênticos consecutivos, o que sinaliza erro no caso do código de Manchester. Um dos motivos para esse erro pode ser um código deslocado em até metade de um ciclo do clock da entrada do decodificador, e neste caso pode-se corrigir o erro através de uma correção simples, como um shift register. Caso o número de bits idênticos consecutivos seja superior a dois, a correção do erro se torna muito mais trabalhosa, motivo pelo qual esse tipo de correção não foi abordado neste estudo.
	
	\subsubsection{Decodificação Viterbi}
	
	\subsubsection{Puncture}
	
	\subsubsection{Deinterleaver}
	
	\subsubsection{Decodificação Reed Solomon}
	
	Esta seção discorre sobre as quatros etapas principais do processo de decodificação de Reed Solomon abordados na execução do projeto.
	
	\subsubsubsection{Cálculo das síndromes}
	
	As síndromes são calculadas através da mensagem recebida e dos símbolos de paridade. O objetivo desse cálculo é identificar num primeiro momento a presença de erros no bloco que foi recebido em relação ao que foi transmitido. Utilizaremos aqui a notação de $R(x)$ para o bloco recebido e $E(x)$ para os possíveis erros. Portanto:
	
	\begin{equation}
	R(x) = C(x) + E(x)
	\end{equation}
	
	
	Caso a mensagem recebida não tenha erros, teremos $E(x)$ formado por 15 símbolos de 0000 no caso de Reed Solomon (15, 7). Se pelo menos um símbolo de $E(x)$ possuir pelo menos um bit diferente de 0, configura-se um erro, e o cálculo das síndromes deverá apontá-lo. Caso o número de símbolos com erro exceda $t$, ou 4 símbolos para um código (15, 7), o erro será identificado nas síndromes, porém não será possível corrigi-lo posteriormente.
	
	No caso de Reed Solomon, as síndromes podem se definir da seguinte maneira:
	
	\begin{equation}
	S_{i} = Q_{i}(x)(x + \alpha^{i}) + R(x)
	\end{equation}
	
	
	No caso específico em que $x$ é $\alpha^{i}$, temos que o primeiro termo da soma é nulo, já que $x + \alpha^{i} = 0000$. Portanto:
	
	\begin{equation}
	S_{i} = R(\alpha^{i})
	\end{equation}
	
	
	E haverá um total de $2t$ síndromes, uma para cada raiz do polinômio codificador $G(x)$. Considerando que existem $v$ símbolos com erros, com $v \leq t$, teremos:
	
	\begin{equation}
	E(x) = V_{1}x^{L_{1}} + ... + V_{v}x^{L_{v}}
	\end{equation}
	
	
	Com $V_{i}$ representando os valores do erro, e $L_{i}$ indicando a localização desses erros. Portanto, para cada síndrome $S_{i}$:
	
	\begin{equation}
	S_{i}(\alpha^{i}) = V_{1}X_{1}^{i} + V_{2}X_{2}^{i} + ... V_{v}X_{v}^{i}
	\end{equation}
	
	
	Os valores de $X_{i}$ são usualmente designados para representar os localizadores de erro. Observe que os índices numéricos não necessariamente indicam o coeficiente do polinômio.
	
	Uma possível representação para o cálculo da síndrome, em hardware, seria a \autoref{Syndrome_logic}. Observe que cada símbolo $C_{j}$ do código é uma das entradas para cada ciclo do cálculo. O parâmetro $\alpha^{i}$ é fixo e seu índice é o mesmo da síndrome de saída. Portanto, para um código Reed Solomon (15, 7), existem 15 símbolos de entrada e 8 síndromes - uma para cada raiz do polinômio codificador.
	
	\begin{figure}[htb]
		\caption{\label{Syndrome_logic} Módulo genérico de cálculo de uma das síndromes}
		\centering
		\includegraphics[width=0.2\textheight]{Syndrome.png}
		\legend{Fonte: @todo figura 126}
	\end{figure}
	
	
	
	\subsubsubsection{Localização dos erros}
	
	O polinômio localizador de erros é construído com auxílio dos localizadores de erro, denotados por $X_{1}$ a $X_{v}$.
	
	\begin{equation}
	\Lambda(x) = (1 + xX_{1})(1 + xX_{2})...(1 + xX_{v})
	\end{equation}
	
	\begin{equation}
	\Lambda(x) =  1 + \Lambda_{1}x^{1} + ... + \Lambda_{v-1}x^{v-1} + \Lambda_{v}x^{v}
	\end{equation}
	
	
	Dessa forma teremos os inversos de $X_{1}$ a $X_{v}$ como raízes deste polinômio, sendo que cada uma dessas raízes torna $\Lambda(x)$ igual a zero. 
	
	\begin{equation}
	\Lambda(X_{j}^{-1}) = \Lambda_{v}X_{j}^{-v} + ... + \Lambda_{1}X_{j}^{-1} + 1 = 0
	\end{equation}
	
	
	Multiplicando essa igualdade por $V_{j}*X_{j}^{i+v}$, temos:
	
	\begin{equation}
	Y_{j}X_{j}^{i+v} + \Lambda_{1}Y_{j}X_{j}^{i+v-1} + ... + \Lambda_{v}Y_{j}X_{j}^{i}
	\end{equation}
	
	Para diferentes valores de $j$, temos:
	\begin{equation}
	S_{i+v} + \Lambda_{1}S_{i+v-1} + ... + \Lambda_{v}S_{i} = 0
	\end{equation}
	
	Dessa forma, pode-se construir a seguinte matriz com um sistema de equações:
	
	\begin{equation}
	\begin{spmatrix}{}
	S_{v-1} & S_{v-2} & ... & S_{0} \\
	S_{v-1} & S_{v-2} & ... & S_{0} \\
	 ... & ... & & ...\\
	S_{2v-2} & S_{2v-3} & ... & S_{v -1} \\
	\end{spmatrix}
	\begin{spmatrix}{}
	\Lambda_{1} \\
	\Lambda_{2} \\
	...	 \\
	\Lambda_{v} \\
	\end{spmatrix}
	=
	\begin{spmatrix}{}
	S_{v}  \\
	S_{v+1}  \\
	...  \\
	S_{2v-1}  \\
	\end{spmatrix}
	\end{equation}
	
	\subsubsubsection{Algoritmo de Berlekamp-Massey}
	
	Resolvendo o sistema anterior, encontram-se os coeficientes do polinômio localizador de erros. Essa resolução pode se feita por mais de uma forma, porém neste estudo é abordado o método de Berlekamp-Massey. Este algoritmo resolve o sistema por meio de aproximações sucessivas do polinômio localizador, iniciando com um $\Lambda(x)$ capaz de produzir $S_{v}$, ou a primeira síndrome. Conforme a seção anterior, calcula-se o próximo termo, $S_{v + 1}$:
	
	\begin{equation}
	S_{v + 1} = S_{v}\Lambda_{1} + S_{v-1}\Lambda_{2} + ... + S_{1}\Lambda_{v}
	\end{equation}
	
	
	Sendo que os valores de $\Lambda$ fazem parte da primeira aproximação. Caso esse valor da síndrome calculada pelo polinômio seja o mesmo valor da síndrome real, ou a diferença $d = 0000$, calcula-se $S_{v + 2}$. Caso contrário, o polinômio deve ser refinado:
	
	\begin{equation}
	\Lambda'(x) = \Lambda(x) +  Kx^{z}\Lambda''(x)
	\end{equation}
	
	
	Onde $\Lambda''(x)$ é o último polinômio localizador estimado antes de haver uma diferença $d \neq 0000$. K é definida como $d''^{-1}d$, com $d''^{-1}$ sendo o inverso da diferença de quando o polinômio $\Lambda(x)$ foi modificado da última vez. Já $z$ é o número de estágios entre $\Lambda''^{+1}(x)$ e $\Lambda(x)$.
	
	Uma vez calculados os coeficientes do polinômio localizador, 
	deve-se descobrir o valor de suas raízes. Como apontado anteriormente, o inverso destas aponta a localização dos erros. Esses valores são encontrados através do método de busca de Chien, que utiliza tentativa e erro, com todos os possíveis valores das raízes.
	
	\subsubsubsection{Valores dos erros}
	
	Existem diversas maneiras de encontrar os valores dos erros. O método abordado aqui - o algoritmo de Forney - utiliza o polinômio avaliador de erros, definido como:
	
	\begin{equation}
	\Omega(x) = \Omega_{v-1}x^{v-1} + ... + \Omega_{1}x + \Omega_{0}
	\end{equation}
	
	
	Os valores dos erros são dados por sua vez por:
	
	\begin{equation}
	V_{j} = X_{j}^{1-b} \frac{\Omega(X_{j}^{-1})}{\Lambda'(X_{j}^{-1})}
	\end{equation}
	
	
	Sendo $\Lambda'(x)$ a derivada de $\Lambda(x)$, e $b$ o índice do primeiro $\alpha$ usado no polinômio codificador, que neste caso será 0.
	
	\subsubsubsection{Síntese}
	
	Um decodificador de Reed Solomon pode ser dividido funcionalmente nos seguintes módulos:
	

	\begin{figure}[htb]
		\caption{\label{RSDecoder_diagrama_logico} Diagrama funcional de decodificação Reed Solomon}
		\centering
		\includegraphics[width=0.7\textheight]{RSdecoder_diagrama.png}
		\legend{Fonte: @todo figura 126}
	\end{figure}
	
	\subsubsubsection{Estratégia}
	
	O primeiro passo para aproximar os algoritmos de uma solução em hardware foi procurar níveis de abstração intermediários. O nível encontrado foi a programação em alto nível, reduzindo módulos como multiplicadores e somadores a funções. Uma das vantagens deste método foi a geração de saídas esperadas para cada módulo funcional, incluindo o bloco de saída final, corrigido ou a ser descartado. Esses dados foram fundamentais para a depuração e correções em hardware. Entretanto, uma das limitações deste método era a de que a linguagem de programação pertence a um paradigma diferente do da descrição de hardware, o que envolveu o uso de máquinas de estado no lugar de loops, por exemplo.  
	
	% ---
	\section{Hardware}\label{sec-hardware}
	% ---
	
	A seguir serão discorridas as implicações da implementação da norma IEEE 802.15.7 em um escopo de hardware analógico, a partir da necessidade de transmitir, receber e converter sinais digitais em analógicos, que então serão convertidos de/para oscilações luminosas.A \autoref{fig_dataflow_analog_circuits}  representa o fluxo dos dados:
	
	\begin{figure}[htb]
		\caption{\label{fig_dataflow_analog_circuits} Diagrama de blocos da conversão digital-analógica e analógica-digital da transmissão de dados.}
		\centering
		\includegraphics[width=0.6\textheight]{circuits/dataflow_analog_circuits.pdf}
		\legend{Fonte: autores.}
	\end{figure}
	
	Os dois primeiros módulos são relativos ao circuito de recepção, enquanto os três últimos são relativos ao transmissor.
	
	% ---
	\subsection{Transmissão}
	% ---
	
	O transmissor do sistema de comunicação LiCy será composto por um conversor digital-analógico e um LED de potência. Os dados serão enviados a partir da FPGA e codificados em 0 e 3.3V, representando os sinais \texttt{0} e \texttt{1} digitais. 
	
	Para cada um desses módulos deve haver um minucioso estudo sobre suas características eletro-eletrônicas, pois existem muitas restrições que devem ser levadas em conta com a frequência de operação $F_{op} = 200 kHz$, como:
	
	\begin{itemize}  
		\item Ruídos são amplificados nessa frequência;
		\item Capacitâncias e Indutâncias parasitas em todos componentes, com ênfase no LED e no transistor;
		\item Prototipação dificultada, pois a breadboard possui muita capacitância em seus contatos;
		\item Alta corrente para ligar um LED de potência.
		\item Componentes limitados pela frequência de operação.
	\end{itemize}
	
	Contornando e solucionando todas as restrições listadas acima, o circuito resultante deverá enviar sinais luminosos a uma frequência de 200kHz.
	
	\subsubsection{Conversor Digital-Analógico}
	Como o LED será de alta potência, a corrente necessária para ligá-lo corretamente é na ordem de grandeza de amperes. Essa corrente de polarização é incompatível com a fornecida pela porta de saída da FPGA (aproximadamente mil vezes menor). Como forma de proteger o circuito da FPGA e também de chavear o LED, será utilizado um transistor de potência.
	
	Além disso, deve-se notar que o método de modulação desejado é OOK (on-off keying). Isso significa que na presença de portadora (sinal 1) o a luz deve estar ligada, enquanto em sua ausência (sinal 0) a luz deve estar desligada.
	
	\paragraph{Curva característica de FET}
		
	\begin{figure}[htb]
		\caption{\label{fig_carac_mosfet} Curva característica de um MOSFET, com indicações das regiões de saturação, corte e triodo.}
		\centering
		%  trim={<left> <lower> <right> <upper>} 
		\includegraphics[page=8,width=0.5\textwidth, trim={16.5cm 9.89cm 3.6cm 3cm},clip]{circuits/Electronics_Ch5.pdf}
		\legend{Fonte: \cite{microelectronics-circuits}}
	\end{figure}
	
	Para projetar um circuito chaveador com um transistor de potência é importante entender seu funcionamento. Um FET é um transistor que utiliza campo elétrico para controlar a condutividade de um tipo de carga de um canal em um semicondutor. Existem dois tipos de canais para transistores: n e p.
	
	Em um n-channel FET, a aplicação de voltagem positiva no Gate em relação a Source permite a livre passagem de eletrons pelo caminho Drain-Source. Analogamente em um p-channel, a aplicação de voltagem positiva no gate bloqueia a passagem de elétrons. Nesse caso, a voltagem aplicada deve ser zero ou negativa para polarizá-lo. Esse comportamento deve ser melhor detalhado utilizando uma curva característica de transistores tipo FET.

	A \autoref{fig_carac_mosfet} caracteriza a resposta $i_{D}$ do transistor tipo FET de acordo com a tensão $V_{GS}$ fornecida, indicando as regiões operação do componente. As regiões de interesse para o chaveamento do LED são as de saturação e corte, e serão detalhadas abaixo.
	
	\subparagraph{Região de Corte}
	
	Na região de corte o transistor se comporta como uma chave aberta. Esse comportamento é visto em todos transistores FET em que se aplica uma tensão $V_{GS} \leq V_{t}$, onde $V_{t}$ indica a tensão de limiar, característica de cada componente. A \autoref{fig_mosfet_cutoff} mostra um circuito com comportamento equivalente.
	
	\begin{figure}[htb]
		\caption{\label{fig_mosfet_cutoff} Equivalência de circuitos com MOSFET em região de corte.}
		\centering
		\includegraphics[width=0.5\textwidth, trim={0cm 2cm 0cm 2cm}, clip]{circuits/mosfet_cutoff.pdf}
		\legend{Fonte: Autores.}
	\end{figure}
	
	Nesse esquemático, R1 representa o resistor que controla a tensão no Gate, R2 e R3 a carga.
	
	Para a aplicação OOK, é interessante que a chave do LED esteja aberta quando a FPGA gerar um zero digital. A restrição mínima da tensão de limiar é $V_{th} > 0V$, 
	
	\subparagraph{Região de Saturação}
	
	Na região de saturação o transistor se comporta como uma chave fechada. Em uma situação real, dependendo de qual $V_{GS} \geq V_{t}$ aplicado, é permitida maior ou menor passagem de corrente $i_{D}$, como pode-se observar na \autoref{fig_carac_mosfet}. Os valores $i_{D}$ não são fiéis a realidade, uma vez que um MOSFET de potência permite passagem de corrente muito maior. O esquemático abaixo mostra um circuito com FET na região de saturação com um circuito com comportamento equivalente, utilizando apenas componentes passivos.
	
	\begin{figure}[htb]
		\caption{\label{fig_mosfet_saturation} Equivalência de circuitos com MOSFET em região de saturação.}
		\centering
		\includegraphics[width=0.5\textwidth, trim={0cm 2cm 0cm 2cm}, clip]{circuits/mosfet_saturation.pdf}
		\legend{Fonte: Autores.}
	\end{figure}
	
	Nesse esquemático, R1 representa o resistor que controla a tensão no Gate, R2 e R3 a carga e R4 a resistência interna $R_{DS}$ do MOSFET.
	
	\paragraph{Conclusão}
	
	O transistor deve ser deixado na configuração de fonte comum da \autoref{fig_common_source}, agindo como chave entre o circuito do LED, VCC e GND. Quando a FPGA gerar o sinal digital 1, o circuito deve atender $V_{in} \geq V_{(i_{D} > Corrente de LED aceso)}$. Da mesma forma, quando o sinal gerado for 0, é necessário projetar $V_{in} < V_{i_{D} \approx 0}$.
	
	\begin{figure}[htb]
		\caption{\label{fig_common_source} FET-n em modo de fonte comum.}
		\centering
		\includegraphics[width=0.5\textwidth, trim={0cm 2cm 0cm 2cm}, clip]{circuits/mosfet_example.pdf}
		\legend{Fonte: Autores.}
	\end{figure}
	
	% ---
	\subsubsection{LED}\label{hard-led}
	% ---
	
	De acordo com a \autoref{tab_phy1} e \autoref{tab_phy2}, para cada camada física implementada é necessário suportar uma frequência de oscilação luminosa mínima:
	
	\begin{itemize}
		\item PHY I: 400kHz
		\item PHY II: 120MHz
	\end{itemize} 
	
	O LED para a transmissão deverá então suportar essas frequências de acordo com a implementação de cada camada. Além disso, também deve realizar a transmissão de luz a distâncias de pelo menos um metro.
	
	Será então necessária a utilização de um LED de potência. É muito importante que o LED escolhido tenha resposta luminosa de acordo com o chaveamento, de forma que a tensão fornecida seja proporcional a luz emitida. Como o grupo não tem nenhum medidor de intensidade luminosa, será muito difícil de caracterizar um problema dessa natureza - como por exemplo, a possibilidade do LED atrasar em relação a excitações em seus terminais. O circuito polarizador de um LED de alta potência pode ser simples, apenas ligando-o a um resistor de alta potência chamado de resistor limitador de corrente.
	
	\begin{figure}[htb]
		\caption{\label{fig_led_circuit}Circuito polarizador de LED, com resistor limitador de corrente}
		\centering
		\includegraphics[width=0.5\textwidth, trim={8cm 8cm 8cm 8.5cm},clip]{circuits/led_circuit.pdf}
		\legend{Fonte: Autores}
	\end{figure}

	A corrente que passa pelo LED, que não pode exceder valores definidos de fábrica pode ser calculada pela fórmula:
	\begin{equation}
	V_{LED} = \frac{V_{CC}}{R_{limit}}
	\end{equation}
	
	\paragraph{Resposta Luminosa}
	
	Como definido no próprio nome, o LED é um Diodo Emissor de Luz. Então para efeitos de simulação pode-se considerar que ele é um diodo.
	\begin{figure}[htb]
		\caption{\label{fig_led_schematic}Símbolo esquemático de um LED, similar ao do diodo}
		\centering
		\includegraphics[width=0.3\textwidth, trim={12cm 9.2cm 12cm 9.5cm},clip]{circuits/led_schematics.pdf}
		\legend{Fonte: Autores}
	\end{figure}
	O circuito proposto deseja oscilar todos os componentes a 200kHz. Isso significa oscilar entre a região de saturação e corte. Ao realizar o fechamento ou abertura de seus terminais, é possível que o componente responda com efeitos de capacitor. As componentes capacitivas passivas e ativas dos componentes criam respostas indesejadas no circuito. Para atenuá-las, é possível utilizar um filtro, que remove esse comportamento indesejado, aplicando uma onda de acordo com a entrada (da FPGA) no LED.
	
	Ainda existe outra opção para não gerar a componente capacitiva ativa no circuito: oscilar a voltagem de entrada apenas dentro da região de saturação do LED. Essa modificação consiste em aplicar uma componente contínua $V_{DC}$ no LED e uma alternada $V_{AC}$ pequena com a portadora do sinal gerado pela FPGA. Esse é muito utilizado em circuitos de fibra ótica, utilizando um componente chamado Bias-Tee.
	
	\begin{figure}[htb]
		\caption{\label{fig_diode_carac} Zona de operação do diodo}
		\centering
		\includegraphics[page=5,width=0.6\textwidth, trim={16cm 2.5cm 2cm 12.5cm}, clip]{circuits/Electronics_Ch3.pdf}
		\legend{Fonte: \cite{microelectronics-circuits}}
	\end{figure}
	
	No gráfico da \autoref{fig_diode_carac} é possível observar a curva de operação do diodo crescente. Ao submetê-lo a uma tensão, há resposta em $I_{D}$, que no caso do LED corresponde a intensidade luminosa. Cada diodo (ou LED) tem sua curva, e será necessário projetar o circuito levando esses parâmetros em consideração.
	
	No entanto, é possível que essa estratégia cause modificações também no circuito do receptor, pois o LED deixará de apagar e acender, apenas oscilando sua intensidade.	
	
	% ---
	\subsection{Recepção}
	% ---
	
	É de responsabilidade do receptor realizar três processos: a recepção dos sinais luminosos, sua amplificação com filtragem e por fim a conversão das ondas em sinais digitais. Com o funcionamento pleno deles, será possível receber um sinal equivalente ao transmitido pela FPGA. Os processos e todos métodos envolvidos estarão explicados em detalhes a seguir na \autoref{hard-photodiode}, \autoref{hard-bandfilter} e \autoref{hard-comparator-filter-and-waves}.
	
	% ---
	\subsubsection{Recepção Luminosa}\label{hard-photodiode}
	% ---
	
	O módulo mais crítico do receptor, que recebe oscilações luminosas e converte-as em sinais analógicos. É muito empregado em circuitos receptores de fibra óptica, CD players, televisões, câmeras e até em medidores de batimento cardíaco. Os fotoreceptores mais comuns são fototransistores ou fotodiodos, que são classificados principalmente de acordo com sua velocidade de chaveamento. 
	
	Um fototransistor é composto por um transistor de junção que responde à incidencia de luz gerando e amplificando corrente elétrica. Seu tempo de resposta é da ordem de $\mu$s. Já o fotodiodo é um diodo semicondutor que gera diferença de potencial ou mudança em sua resistência quando iluminado, com o tempo de resposta usualmente em ns, devido a sua natureza semicondutora e arquitetura de silício.
	
	Para o projeto, é mais interessante a escolha do fotodiodo, pela sua alta velocidade de resposta, tornando a onda recebida mais fiel possível a realidade.
	
	O fotodiodo tem dois principais modos de operação com as seguintes características:
	
	\begin{table}[ht]
		\caption{Comparação entre modos de operação do fotodiodo.}
		\centering
		\begin{tabular}{c c c}
			\hline
			Modo de Operação  & Polarização & Características \\ \hline
			Fotovoltaico & não & $I_{dark}$ menor, resposta lenta \\
			Fotocondutivo & negativa & $I_{dark}$ maior, resposta rápida \\ \hline
		\end{tabular}
		\label{tab_photodiode_comp}
	\end{table}
	
	Como velocidade de resposta é prioritária na aplicação de comunicação, será utilizado o modo fotocondutivo. A polarização reversa aumenta o comprimento da região de depleção e diminui a capacitância de junção, aumentando a performance em altas frequências.
	
	Mas como o fotodiodo gera apenas corrente, é necessário convertê-la em tensão para amplificar o sinal e filtrar os eventuais ruídos. A conversão será feita por um amplificador de transimpedância.
	
	\paragraph{Amplificador de Transimpedância}
	
	O comportamento de um amplificador de transimpedância é simples: converter corrente em tensão. Ele normalmente é utilizado com componentes em que resposta em corrente é mais linear que a resposta em tensão, como no caso o fotodiodo. 
	
	O amplificador apresenta baixa impedância de entrada para isolar o fotodiodo da voltagem de saída. Em relação a saída, ao contrário do fototransistor, que tem corrente de saída a $\mu$A, o fotodiodo gera uma corrente na ordem de grandeza de pA. Para converter essa corrente baixa em voltagem útil para o circuito, é necessário realizar a amplificação desse sinal utilizando um resistor de feedback $R_{F}$, rotulado como R1 na \autoref{fig_transimpedance_amp_simple}.
	
	\begin{figure}[htb]
		\caption{\label{fig_transimpedance_amp_simple} Circuito Amplificador de Transimpedância}
		\centering
		\includegraphics[width=0.6\textwidth, trim={2cm 3.8cm 2cm 3.8cm}, clip]{circuits/transimpedance_amp_simple.pdf}
		\legend{Fonte: Autores.}
	\end{figure}
	
	O ganho de amplificação é dado pela fórmula:
	
	\begin{equation}
	V_{out} = - I_{fotodiodo} \cdot R_{feedback}
	\end{equation}
	
	Como $I_{fotodiodo}$ é da ordem de pA, $R_{F}$ deve ser grande (M$\Omega$) para tornar a voltagem compatível com níveis TTL. Nota-se que $V_{out}$ é negativo pois o amplificador se encontra na configuração inversora. A \autoref{plot-post-tia} ilustra o comportamento da saída do Amplificador de Transimpedância.
	
	\begin{figure}[h!]
		\caption{\label{plot-post-tia} Saída esperada do Amplificador de Transimpedância, com amplitude de $i_{D} \cdot R_{F}$, com componente $V_{DC} = L$ variável.}
		\centering
		\begin{tikzpicture}
		\begin{axis}[
		xmin=0, xmax=25,
		ymin=0, ymax=2,
		axis lines=middle,
		xticklabels={,,},
		ytick={0.3, 1, 1.7},	
		yticklabels={$L-A_{i_{D} \cdot R_{F}}$,$L$,$L+A_{i_{D} \cdot R_{F}}$},
		%ylabel near ticks,
		%			ylabel style={yshift=-0.5cm},
		xlabel shift = 2 pt,
		xlabel style={yshift=-1cm},
		xlabel={[$t$]},
		ylabel={[$V_{out}$]}
		]
		\addplot[smooth, domain=0:8*pi, color=red]{0.7*sin(deg(x/2)) + 1};
		\addplot[domain=0:8*pi]{1};
		\end{axis}
		\end{tikzpicture}
		\legend{Fonte: Autores}
	\end{figure}
	
	Após esse estágio de recepção, obtém-se uma onda com componente $V_{DC} = L$. Essa componente é variável e depende de alterações na intensidade de luz, variações na distância do transmissor com receptor, entre outros fatores. A amplitude da onda depende da corrente  $i_{D}$ do fotodiodo e da resistência de feedback $R_{F}$ do circuito amplificador. 
	
	% ---
	\subsubsection{Conversor Digital-Analógico}\label{hard-comparator-filter-and-waves}
	% ---
	
	Para poder realizar estágios adicionais de amplificação e comparação para obter uma saída compatível com a entrada da FPGA, deve-se entender o funcionamento de um comparador. O circuito comparador utiliza um amplificador operacional com alto ganho sem realimentação e recebe dois sinais: uma voltagem de entrada $V_{in}$ e uma voltagem de referência $V_{ref}$. Ele realiza a comparação do nível de tensão analógico $V_{in}$ com $V_{ref}$ e produz saída de acordo com essa comparação. Seu desenho esquemático pode ser visto na \autoref{fig_comparator_circuit} e o comportamento de sua saída na \autoref{tab_comparator_behaviour}. 
	
	\begin{figure}[htb]
		\caption{\label{fig_double_comparator}Comparador e curva de resposta}
		\begin{subfigure}{.5\textwidth}
			\caption{\label{fig_comparator_circuit}Circuito comparador simples}
			\centering
			\includegraphics[width=0.77\textwidth, trim={7.5cm 5cm 7.5cm 5.5cm},clip]{circuits/comparator_amp.pdf}
			\legend{Fonte: Autores.}
		\end{subfigure}
		\begin{subfigure}{.5\textwidth}
			\caption{\label{fig_comparator_transfer}Curva de resposta de comparador real}
			\centering
			\includegraphics[page=1,width=0.8\textwidth, trim={6.9cm 5.5cm 6.9cm 19.25cm},clip]{circuits/lecture_comparator.pdf}
			\legend{Fonte: \cite{comparator-ampop-lecture}}
		\end{subfigure}
	\end{figure}
	
	\begin{table}[ht]
		\caption{Comportamento real de um comparador com amplificador operacional}\label{tab_comparator_behaviour}
		\centering
		\begin{tabular}{c c}
			\hline
			$V_{in}$ & $V_{out}$\\ \hline
			$V_{in} > V_{ref}$& $V_{CC}$\\
			$V_{in} \approx V_{ref}$& depende de $V_{\delta-}$ e $V_{\delta+}$\\
			$V_{in} < V_{ref}$& $V_{EE}$\\
			\hline
		\end{tabular}
	\end{table}
	
	Na primeira e terceira cláusula da \autoref{tab_comparator_behaviour} o amplificador operacional opera na região de saturação. No entanto, seu funcionamento para entrada $V_{in} \approx V_{ref}$ polariza o semicondutor em uma região linear que depende de dois parâmetros adicionais:
	\begin{equation}
	V_{\delta+} = \frac{V_{DD}}{A}
	\end{equation}
	\begin{equation}
	V_{\delta-} = \frac{V_{EE}}{A}
	\end{equation}
	Nesse intervalo $V_{\delta-} < V_{in} < V_{\delta+}$ (ilustrado em \autoref{fig_comparator_transfer}), o comportamento da saída é diferenciado e depende do ganho de loop aberto A, que para circuitos reais é muito grande $A=20000$. Os valores $V_{\delta-}$ e $V_{\delta+}$ então são da ordem de  $\mu$V, definindo a tensão mínima (ou máxima) da entrada para que o comparador realize uma comparação adequada. Com uma amplitude $V_{in_{AC}}$ alternada suficientemente alta, é possível tornar a curva de resposta mais íngreme melhorando o tempo de resposta do componente. A amplitude pode ser ajustada com o resistor de feedback $R_{f}$ do estágio anterior. Mesmo com essas correções, a onda comparada pode defasar um pouco na saída.
	
	\subsubsection{Filtro Passa-Altas}
	
	Como foi observado na \autoref{plot-post-tia}, a onda recebida possui uma componente $V_{DC} = L$ variável. Essa ela não tem valor fixo, então não é possível definir a tensão $V_{ref}$ para comparar. Nesse caso existe a necessidade da eliminação da componente $V_{DC} = L$.
	
	Para isso, pode-se utilizar um simples circuito RC de primeira ordem, que age como filtro passa altas, esquematizado na \autoref{plot-post-highpass-filter}. Seu funcionamento se baseia no capacitor C, que em baixas frequências apresenta alta reatância, atuando como um aberto e bloqueando qualquer sinal abaixo da frequência de corte $f_{c}$. Acima dessa frequência a reatância do capacitor é reduzida suficientemente para agir como um curto circuito, permitindo qualquer entrada $V_{in}$ passar diretamente para saída $V_{out}$. A frequência de corte $f_{c}$ só pode ser obtida com a presença do resistor R e do capacitor C juntos, que geram a constante de tempo $\tau$. O cálculo desses valores se encontra abaixo:
	\begin{equation}
	\tau = R \cdot C
	\end{equation}
	\begin{equation}
	f_{c} = \frac{1}{2 \cdot \pi \cdot \tau}
	\end{equation}
	
	Ainda existe a possibilidade da fase de resposta do circuito se deslocar devido à presença do capacitor. A fórmula que calcula sua defasagem/adiantamento $\phi$ é:
	
	\begin{equation}
	\phi = arctan{\left(\frac{1}{2 \cdot \pi \cdot f_{op} \cdot R \cdot C}\right)}
	\end{equation}
	
	A \autoref{plot-post-highpass-filter} ilustra o comportamento da saída do filtro passa-altas juntamente com o esquemático do filtro passa-altas.
	
	\begin{figure}[h]
		\caption{\label{plot-post-highpass-filter} Saída esperada após remoção do acoplamento DC, aplicando filtro passa-alta RC de primeira ordem (à direita), com defasagem de 45$\degree$. A área hachurada representa tensão inadequada para o comparador.}
		\begin{subfigure}{.5\textwidth}
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			xmin=0, xmax=25,
			ymin=-1, ymax=1,
			axis lines=middle,
			xticklabels={,,},
			ytick={-0.7, 0, 0.7},	
			yticklabels={$-A_{i_{D} \cdot R_{F}}$,$0$,$A_{i_{D} \cdot R_{F}}$},
			%ylabel near ticks,
			%			ylabel style={yshift=-0.5cm},
			xlabel shift = 2 pt,
			%xlabel style={yshift=-1cm},
			xlabel={[$t$]},
			ylabel={[$V_{out}$]},
			after end axis/.code={
				\path (axis cs:0,0) 
				%			node [anchor=north west,yshift=-0.075cm] {$V_{EE}$};
				node [anchor=south east,xshift=-0.2cm, yshift=-0.3cm] {$0$};
			}
			]
			\addplot[name path=f, smooth, domain=0:8*pi, color=red]{0.7*sin(deg(x/2 - pi/2))};
			\addplot[name path=axis, domain=0:8*pi]{0};
			\addplot[fill=none]
			fill between[
			of=f and axis,
			soft clip={domain=0:8*pi},
			split,
			every segment no 0/.style = {pattern=north east lines},
			every segment no 2/.style = {pattern=north east lines},
			every segment no 4/.style = {pattern=north east lines}
			];
			\end{axis}
			\end{tikzpicture}
		\end{subfigure}%
		\begin{subfigure}{.5\textwidth}
			\centering
			\includegraphics[width=1\textwidth, trim={3cm 0cm 3cm 3cm},clip]{circuits/highpass_filter.pdf}
		\end{subfigure}
		\legend{Fonte: Autores}
	\end{figure}
	\subsubsection{Acoplamento DC}
	Com a aplicação do filtro passa-altas agora a onda gerada têm componente $V_{DC} = 0$ fixa - observada na parte hachurada da \autoref{plot-post-highpass-filter} -, que ainda necessita correção, pois é uma tensão incompatível com o circuito.
	
	O funcionamento do comparador (e de qualquer amplificador operacional) depende altamente do fato de que as voltagens de entrada $V_{in}$ e $V_{ref}$ estejam dentro do intervalo de alimentação. Caso as tensões aplicadas nas entradas sejam muito altas (ou baixas), o amplificador pode operar incorretamente, ser reversamente polarizado e até ser danificado. Esses valores costumam estar presentes em datasheets de componentes em uma tabela chamada	\textbf{ABSOLUTE MAXIMUM RATINGS}. Como foi decisão de projeto o fato de que o sistema de comunicação utilizaria apenas uma fonte de alimentação, essa restrição será aplicada para todos os componentes do circuito.
	
	Apenas uma fonte significa que o circuito terá apenas alimentação positiva disponível em seus terminais: 
	\begin{equation}
	V_{in}, V_{ref} \in [V_{EE} \geq 0, V_{CC} > V_{EE}]
	\end{equation}
	Portanto o componente não conseguirá realizar a comparação corretamente. Para resolver esse problema pode-se adicionar um acoplamento $V_{DC} = V_{ref}$ fixo, que também será utilizado na entrada de referência do comparador. E etapa de filtro pode ser realizada juntamente com a adição de $V_{ref}$, utilizando um circuito levemente modificado.
	
	\begin{figure}[h]
		\caption{\label{plot-post-bias1v} Gráfico com adição de componente DC $V_{DC} = V_{ref}$ fixa e filtro passa-altas modificado. Agora não existe tensão }
		\begin{subfigure}{.5\textwidth}
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			xmin=0, xmax=25,
			ymin=0, ymax=2,
			axis lines=middle,
			xticklabels={,,},
			ytick={0.3, 1, 1.7},	
			yticklabels={$V_{ref}-A_{i_{D} \cdot R_{F}}$,$V_{ref}$,$V_{ref}+A_{i_{D} \cdot R_{F}}$},
			%ylabel near ticks,
			%ylabel style={yshift=-0.5cm},
			xlabel shift = 2 pt,
			xlabel style={yshift=-1cm},
			xlabel={[$t$]},
			ylabel={[$V_{out}$]}
			]
			\addplot[smooth, domain=0:8*pi, color=red]{0.7*sin(deg(x/2 - pi/2)) + 1};
			\addplot[domain=0:8*pi]{1};
			\end{axis}
			\end{tikzpicture}
		\end{subfigure}
		\begin{subfigure}{.5\textwidth}
			%\caption{\label{hard-post-bias1v} Filtro passa-altas com adição de $V_{DC} = 1V$.}
			\centering
			\includegraphics[width=1\textwidth, trim={3cm 0cm 3cm 3cm},clip]{circuits/highpass_filter_bias.pdf}
		\end{subfigure}
		\legend{Fonte: Autores}
	\end{figure}

	 A figura \autoref{plot-post-bias1v} ilustra a onda modificada, com voltagem de referência fixa agora. Após todas essas etapas, é possível realizar de fato a etapa de comparação. Idealmente a onda ficaria similar a \autoref{plot-post-comparator}.
	
	\begin{figure}[h]
		\caption{\label{plot-post-comparator} Saída esperada após a etapa de comparação em verde.}
		\centering
		\begin{tikzpicture}
		\begin{axis}[
		xmin=0, xmax=25,
		ymin=0, ymax=1.8,
		axis y line=middle, 
		axis x line=bottom,
		xticklabels={,,},
		ytick={0, 0.7, 1.4},	
		yticklabels={$V_{EE}$, $V_{ref}$, $V_{CC}$},
		%ylabel near ticks,
		ylabel style={yshift=0cm, xshift=0cm},
		xlabel style={xshift=3cm, yshift=0.1cm},
		legend style={anchor=north east, xshift=0.5cm},
		xlabel={[$t$]},
		ylabel={[$V_{out}$]},
		after end axis/.code={
			\path (axis cs:0,0) 
%			node [anchor=north west,yshift=-0.075cm] {$V_{EE}$};
			node [anchor=south east,xshift=-0.075cm, yshift=-0.3cm] {$V_{EE}$};
		}
		]
		\addplot[smooth, domain=0:8*pi, color=red]{0.35*sin(deg(x/2)) + 0.7}; \addlegendentry{$V_{in}$};
		\addplot[color=green] coordinates {(0, 1.4) (2*pi,1.4) (2*pi,0) (4*pi,0) (4*pi,1.4) (6*pi,1.4) (6*pi,0) (8*pi,0)}; \addlegendentry{$V_{comp}$};
		%\addplot[color=green] coordinates {(0,0) (0, 1.4) (2*pi,1.4) (2*pi,0) (4*pi,0) (4*pi,1.4) (6*pi,1.4) (6*pi,0) (8*pi,0)}; \addlegendentry{$V_{comp}$};
		\addplot[domain=0:8*pi]{0.7};
		\end{axis}
		\end{tikzpicture}
		\legend{Fonte: Autores}
	\end{figure}
		
	Com a sensibilidade ajustada de acordo, é possível que o sinal recebido seja muito semelhante (se não exatamente igual) ao enviado. Caso a saída não esteja adequada, é possível que seja necessário realizar mais um estágio de amplificação e filtração após o filtro passa-altas.
	
	% ---
	\subsubsection{Filtro Passa-Faixas}\label{hard-bandfilter}
	% ---
	
	Com intuito de reduzir o ruído em circuitos de amplificação com amplificadores operacionais, especifica-se um modelo de circuito passa-faixas na \autoref{fig_opampdif}.
	
	\begin{figure}[h!]
		\caption{\label{fig_opampdif}Circuito amplificador de diferenças.}
		\centering
		\includegraphics[width=0.6\textwidth, trim={5cm 12.29cm 17.6cm 4.3cm},clip]{circuits/opamp-dif2.pdf}
		\legend{Fonte: Autores}
	\end{figure}
	
	De acordo com as tabelas \ref{tab_phy1} e \ref{tab_phy2}, o intervalo da frequência do \textit{clock} luminoso é de 200kHz até 120MHz. Deseja-se então  permitir a passagem dessas, limitando as frequências fora desse intervalo. Com o uso do passa baixas e passa altas da figura acima, pode-se realizar essa limitação adequando os resistores e capacitores do circuito.
	
	\begin{comment}
	Ninguém gosta de imagens da wikipedia
	\begin{figure}[htb]
		\caption{\label{fig_frequenciacentral}Um gráfico em escala logaritmica mostrando a banda de passagem B, a frequência de corte inferior $f_{L}$, a frequência de corte superior $f_{H}$ e a frequência central fo para um circuito passa faixas.}
		\centering
		\includegraphics[width=0.5\textwidth, trim={4.5cm 17cm 3.3cm 2cm},clip]{circuits/freq-corte.pdf}
		\legend{Fonte: Inductiveload, Wikipedia}
	\end{figure}
	\end{comment}
	
	Deve-se levar em conta também o ganho do circuito, que é dado pela fórmula:
	
	\begin{equation}
	V_{out} = V_{in} \cdot \frac{R2}{R1}
	\end{equation}
	
	O cálculo da frequência de corte inferior do circuito é dado por: 
	
	\begin{equation} \label{eq:1}
	f_{ci} = \frac{1}{2 \cdot \pi \cdot R1 \cdot C1}
	\end{equation}
	
	No caso da frequência de corte superior, pode-se realizar o cálculo utilizando a fórmula abaixo:
	
	\begin{equation} \label{eq:2}
	f_{ci} = \frac{1}{2 \cdot \pi \cdot R2 \cdot C2}
	\end{equation}
	
	O cálculo da frequência central é feita pela \texttt{média geométrica} das frequências calculadas em \ref{eq:1} and \ref{eq:2} abaixo: 
	
	\begin{equation} \label{eq:3}
	f_{o} = \sqrt{f_{ci} \cdot f_{cs}}
	\end{equation}
	
	A banda de passagem do circuito é calculada pela subtração da frequencia de corte superior pela inferior:
	
	\begin{equation} \label{eq:4}
	BW = f_{cs} - f_{ci}
	\end{equation}

	% ---
	\subsection{Microcontrolador}\label{hard-uc}
	% ---
	
	O microcontrolador escolhido foi o Raspberry Pi.

	% @TODO insira imagem do rasp aqui %
	
	Explicação do porquê foi escolhido Raspberry Pi: sistema linux, GPIO de fácil acesso, programação python
	
	% ---
	\subsubsection{Opções Consideradas}\label{uc-options}
	% ---
	
	Raspberry Pi, Galileo, 
	
	% ---
	\subsubsection{Tabela Comparativa}\label{uc-table}
	% ---
	
	% ---
	\subsection{FPGA}\label{hard-fpga}
	% ---
	
	FPGA (Field-Programmable Gate Array) é uma tecnologia que utiliza chips de silício reprogramáveis para obter circuitos customizáveis, latência a nível de hardware\footnote{muito muito rápido} e vazão muito alta\footnote{devido ao alto grau de paralelismo}. No projeto LiCy, como o fluxo de informações é muito alto (requisito de projeto de 1Gbps), é necessário realizar múltiplos processos ao mesmo tempo para lidar com os dados:
	
	\begin{itemize}  
		\item Recebimento/Transmissão de dados
		\item Cálculo de paridade
		\item Correção de erros\footnote{apenas para recebimento}
		\item (De)codificação de dados
	\end{itemize}
	
	\begin{table}[htbp]
		\caption{\label{tab_phy1} Modos de operação da camada PHY I de Li-Fi}
		
		\centering
		%  trim={<left> <lower> <right> <upper>} 
		\includegraphics[clip, trim=37mm 151mm 36mm 51mm,  width=0.7\textwidth]{pag213.pdf}
		\legend{Fonte: IEEE 802.15.7}
	\end{table}
	
	\begin{table}[htbp]
		\caption{\label{tab_phy2} Modos de operação da camada PHY II de Li-Fi}
		\centering
		\includegraphics[clip, trim=46.55mm 36.79mm 46.74mm 142.30mm,  width=0.7\textwidth]{pag213.pdf}
		\legend{Fonte: IEEE 802.15.7}
	\end{table}
	
	Essa tecnologia é ideal para criar protótipos de circuitos digitais. Existe neste caso a facilidade de mudar o arranjo de componentes e vias de dados, bem como a possibilidade de simulá-los e depurá-los antes mesmo de gravar as configurações no hardware. Estes são elementos chave para a criação de um ambiente controlado, para testar as funcionalidades do produto desenvolvido. Sendo assim, um dos fatores que mais motivou a escolha dessa tecnologia neste projeto.
	
	O projeto de uma FPGA possui características que anteriormente estavam associadas a sistemas baseados em processadores. Uma delas é o uso de ferramentas e interfaces de alto nível, usando diagramas de bloco representando comportamentos e linguagens de descrição de hardware (na sigla em inglês, HDL), que no entanto diferem em muito de linguagens de programação como C. 
	
	A principal vantagem do uso de uma FPGA em relação a microcontroladores está na independência das operações de processamento, que por estarem em circuitos paralelos não precisam dividir recursos, como um mesmo núcleo por exemplo. Entretanto, o alto grau de paralelismo pode resultar em maiores desafios como garantir o sincronismo e lidar com inconsistência de dados no nível de circuito. Ainda assim, é preferível neste projeto lidar com esses desafios para se beneficiar do ganho em latência e vazão de dados.

	% ---
	\section{Software}\label{sec-software}
	% ---
	
	Explica as escolhas feitas no aspecto do software do projeto.
	
	% ---
	\subsection{VHDL}\label{soft-vhdl}
	% ---
	
	VHDL, sigla do inglês para VHSIC Hardware Description Language, é uma linguagem de descrição de hardware.  Entre suas características incluem-se uma tipagem forte, comportamento determinístico em comparação com outras linguagens de descrição de hardware como Verilog, e aplicação maior em FPGAs na área acadêmica. Por esses motivos, a curva de aprendizado pode ser mais inclinada no início, mas uma vez ultrapassada a barreira da maior rigidez no processo de compilação, a detecção de erros em código é facilitada.
	
	Uma linguagem de descrição de hardware tem por objetivo modelar sistemas digitais através de código. Alguns parâmetros importantes dessa modelagem são o comportamento, a estrutura e o tempo - todos cobertos por VHDL. Analogamente às linguagens de programação, VHDL possui categorias de dados, como sinais, variáveis e constantes, que servem para representar fios, registradores e outros elementos de circuitos relacionados a dados. 
	
	Além disso, a linguagem de VHDL é uma ferramenta interessante para a construção de máquinas de estado finitos. A síntese desse tipo de circuito é essencial para a implantação em hardware de algoritmos que envolvem iteração, o que é mais uma forte justificativa para a escolha desta ferramenta neste estudo. Outro fator importante levado em consideração para essa escolha foi a familiarização prévia com VHDL durante o curso, nas matérias de Laboratório, Organização e Arquitetura de Sistemas Digitais, o que auxiliou na escalada da curva de aprendizado.
	
	
	%--- Obs: essa justificativa sobre as matérias é ok? 
	
	
	*ref: Very High Speed Integrated Circuit

	
	% ---
	\subsubsection{Opções Consideradas}\label{vhdl-options}
	% ---
	%-- VHDL e Verilog?
	%Essa parte é necessária? 
	%Explicação de quais foram as opções consideradas.
	
	% ---
	\subsubsection{Tabela Comparativa}\label{vhdl-table}
	% ---
	
	Tabela de opções consideradas.
	
	% ---
	\subsection{Quartus}\label{soft-quartus}
	% ---
	
	Quartus é um software de programação de dispositivos lógicos, desenvolvido pela Altera, subsidiária da Intel, que fabrica dispositivos lógicos programáveis, como as FPGAs citadas anteriormente. Algumas das vantagens dessa ferramenta são a possibilidade de sintetizar circuitos a partir de diagramas lógicos,  simular o comportamento de circuitos no tempo, controlando entradas através de testbenches, e uma interface relativamente simples para se programar uma FPGA.
	
	Dentro do contexto do estudo de sistemas digitais, Quartus foi uma ferramenta recorrente para os integrantes do grupo no passado. Ademais, o fato desta ferramenta se integrar com famílias de FPGAs como Cyclone ou MAX foi interessante, já que isto tornou possível o uso da infra-estrutura presente nos laboratórios da Universidade.
	
	%--- necessário aprimorar essa justificativa, sugestões?
	
	% ---
	\subsubsection{Opções Consideradas}\label{quartus-options}
	% ---

	
	% ---
	\subsubsection{Tabela Comparativa}\label{quartus-table}
	% ---
	
	
	% ---
	\subsection{Android}\label{soft-android}
	% ---
	
	Explicação do porquê foi escolhido Android.

